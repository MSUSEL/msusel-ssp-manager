docker-compose --rmi all




Building flask
DEPRECATED: The legacy builder is deprecated and will be removed in a future release.
            Install the buildx component to build images with BuildKit:
            https://docs.docker.com/go/buildx/



    Ok, This is the flow for generate. 
    It is completely integrated into the flask container. The generate requirements were added to
    flask requirements.
    There's a new route in app.py for generating the templates. (generate.py is in the same folder)
    The generated files can be accessed in the host at /tmp (I'm generating ssp.yaml and ap.yaml
    froma profile.yaml)

    No le estamos pasando el nombre del profile. Esta hardcoded como profile.yaml en generate.py
    So por ahora, cualquier file que queramos test se tienen que llamar profile.yaml

TODO:
    Se debe seguir trabajando. (ver si podemos refinar los templates. 
    Podemos eliminar el route a results y volver a "/"?)




 - Where are we creating this venv? (habria que instalar virtualenv en el container)
 Vamos a imaginarnos el workflow.
 (NO) Lo primero es que necesitamos el proyecto a analizar en el dependencies folder, 
 so el user tendria que edita el dockerfile de este container para que se copie ese codigo
 (No estan dificil, pero eso es lo que queremos? )

 (DONE)
 0) Podemos correr bandit en un container? (Yes)
 Lo mas facil es anadirlo a los requirements de flask y ver si corre. (DONE)
 **El artifacts folder y el bandit_output_test.json file tienen que existir,
 si no bandit se queja.
 Necesitamos una f para llamar a run bandit. (Se ve mas organizado si meto los files de
 matching en un folder aparte dentro de flask? Esta no es la prioridad. Check later.)
 
 (DONE)
 1) Podemos tener un folder distinto para el proyecto y tener un volume en el container 
 para ese folder distinto. El user pone el proyecto el ese folder en el host.
 (PA ESO QUE LO PONGA AQUI Y NOS AHORRAMOS LA COMPLICACION. ./dependencies)
 El container tiene un volume desde un proyect folder a ese folder en el host.
 La pregunta es, El proyecto tiene que estar en el dependencies folder por alguna otra razon?


 (DONE)
 2) Como flask le avisa a este container que tiene que arrancar? (debe ser como el CLI)
 NO HAY QUE CREAR OTRO CONTAINER
 Vamos a empezar por el UI y crear una ruta para effective vulnerabilities. (index.html)
 




(DONE)
current command:
python3 prepareProject.py dependencies.abstractClass main_function
(Tenemos estos dos argumentos hardcoded, arreglar)
 3) Como este container le avisa a flask que termino? (como el CLI)
 Tenemos una ruta y vamos a hacer todo en esa ruta.
 Anadir virtualenv a los requirementsDespues vamos a correr prepareProject. (DONE)
 Copiar todos los files (DONE)
 Podemos crear el venv (DONE)
 Ok, it executes/

Note: 
- Remember that bandit runs over the dependencies folder. (Doesn't it make more sense to have the 
project on the same folder? Yes, I think so.)
- Profiler executes the program that it receives as argument. 
(It takes care of the dependencies)

 TODO:
 - Hay un misterio que el write a demofile2 en parseBanditOutput no ejecuta,
 pero tenemos el output de este file. Check. (Ahora aparece)



 4) Hay que formatear el output para producir los graphs y el table?
 Primero crear el input para el html form. 
 (por ahora lo corren manual. Si es facil automatizar, lo automatizamos)
 Vamos a crear otro artifact.
 Una lista de objetos {"cwe":"id"} llamada cwe.json 
 (tenemos que ponerla en el shared volume para poder test it)
 Tenemos la list. (prepareCWEList.py, estoy merging las listas called 
 y vulnsNotInFunctions para propositos de query a BRON)
   - Should we remove duplicates. (DONE)
   (Pueden pertenecer a files distintos, pero van a map al mismo control. 
   Esta lista es solo para determinar los recomended control.
   So si, remove duplicates. Ahora.)

 Generate dejo de funcionar. (habia un tag </form> de mas en index.html)   (DONE)
 La lista de cwe que le estoy pasando no procesa los templates para los resultados.
 (hubo que arreglar el query en read_cwe, lo hice como en read_cve y funciona.
 Pero no tenemos nada para map. Necesitamos mas vulns. Quizas buscar un proyecto mas
 grande? => primero pasar la otra lista de los vulns not in functions.
 
 ==> hay que pasarle las otras listas a prepareCWEList, y para este proposito, 
 hay que merge las dos listas. (DONE)

 )
Bug (VAMOS POR AQUI)
Tengo una lista grande de cwe (en downloads), pero no estoy obteniedo nada en los grafos o 
el table. (Nota: si los elementos no estan con double quotes {"cwe":"id"}, se rompe.)




   - Donde anadimos al output final filename, line number, ...
   (Usamos los artifacts que tenemos)




 5) Ademas, queremos un table adicional exclusivo para el resultado de este container.
 Y queremos visualizar el call graph? (Es bien grande, es util?)


 - Do we need a different volume for matching functionality?
    - what about bandit?
 - Can we automate the results from matching  (along with a controls file) 
 to go into the DB to produce the graphs and the table?
