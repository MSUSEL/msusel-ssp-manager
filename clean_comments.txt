
INSTALL SECTION
Command to copy the repo, including the BRON submodule:
git clone --recurse-submodules <repository-url>

The settings.json file in VS Code needs to be modified.
The schemas enable autocompletion and point out incorrect values in teh OSCAL documents.
The schemas are in the /flask/oscal_schemas directory. 
The VS Code IDE settings were modified as follows: 
file -> preferences -> settings and in the search bar input 'json schema'. 
Select workspace and edit settings.json. 

VS Code settings.json content (*MUST CHOSE WORKSPACE)
{
    "json.schemas": [
        { "fileMatch": ["/flask/oscal_schemas/assessment-plans/*"], 
        "url": "./flask/oscal_schemas/oscal_assessment-plan_schema.json" },
        { "fileMatch": ["/flask/oscal_schemas/assessment-results/*"],
        "url": "./flask/oscal_schemas/oscal_assessment-results_schema.json" },
        { "fileMatch": ["/flask/oscal_schemas/catalogs/*"],
        "url": "./flask/oscal_schemas/oscal_catalog_schema.json" },
        { "fileMatch": ["/flask/oscal_schemas/components/*"],
        "url": "./flask/oscal_schemas/oscal_component_schema.json" },
        { "fileMatch": ["/flask/oscal_schemas/POAMs/*"],
        "url": "./flask/oscal_schemas/oscal_poam_schema.json" },
        { "fileMatch": ["/flask/oscal_schemas/profiles/*"],
        "url": "./flask/oscal_schemas/oscal_profile_schema.json" },
        { "fileMatch": ["/flask/oscal_schemas/system-security-plans/*"],
        "url": "./flask/oscal_schemas/oscal_ssp_schema.json" }
    ],
    "yaml.schemas": {
        "./flask/oscal_schemas/oscal_assessment-plan_schema.json": ["/flask/oscal_schemas/assessment-plans/*"],
        "./flask/oscal_schemas/oscal_assessment-results_schema.json": ["/flask/oscal_schemas/assessment-results/*"],
        "./flask/oscal_schemas/oscal_catalog_schema.json": ["/flask/oscal_schemas/catalogs/*"],
        "./flask/oscal_schemas/oscal_component_schema.json": ["/flask/oscal_schemas/components/*"],
        "./flask/oscal_schemas/oscal_poam_schema.json": ["/flask/oscal_schemas/POAMs/*"],
        "./flask/oscal_schemas/oscal_profile_schema.json": ["/flask/oscal_schemas/profiles/*"],
        "./flask/oscal_schemas/oscal_ssp_schema.json": ["/flask/oscal_schemas/system-security-plans/*"]
    }
}

CHANGES MUST BE SAVED.


RUN SECTION 
generate-env.sh file in the clean_ssp directory. 
This file needs chmod +x generate-env.sh to execute. 
It needs to be run at the start of the session, before running docker-compose up. 
It generated an environment variable (EV) that holds the path to the clean_SSP directory.
The docker-compose.yml file was modified to use this EV in the path for the volume. 
The EV is also passed to the flask container as an argument (arg). 
The flask Dockerfile was modified to receive this arg and to save it as an EV. 
app.py then uses this EV from the container and passes it to app.config['HOST_VOLUME_PATH']. 
This path is later passed when the processing container is to be executed.

The script also generates UID and GID EVs that are osed to change ownership of the 
generated files (so they can be edited).

The only command that needs to be run is (in the clean_SPP directory):
./generate-env.sh (I think it only needs to be run once, to create the .env file)

ATENTION THAT THESE VARAIBLES ARE ONLY SET ON THE CURRENT SHELL.


***move-files.sh and clean-shared-dir.sh scritps should be run with sudo.
(When we move, we are moving the files in the host. 
The container will have the same files as before:
verify that this doesn't messes up the functionality.
Are there cases when we don't want to overwrite?

)



The `hsperfdata_root` directory is created by the Java Virtual Machine (JVM) when it runs. 
It's used to store performance data for the running JVM process.
The name of the directory comes from "HotSpot Performance Data", 
where HotSpot is the JVM implementation used in Oracle's JDK and OpenJDK. 
The `_root` part is typically the username of the user running the JVM process.
This directory is usually created in the temporary directory of the operating system, 
but if a JVM process is run with a different user home directory or temp directory, 
it can appear in other places, such as a shared volume in Docker.
In general, you can safely ignore this directory. 
It's automatically deleted when the JVM process exits normally. 
However, if the JVM process is killed forcefully, the directory may not be cleaned up.
(We need to see if we can end the process gracefully)





Flask secret key can be set in flask/dockerfile:
ENV 'SECRET_KEY'='value'

The UPLOADS_FOLDER and the OSCAL_FOLDER are also set as environment variables in the dockerfile.
It is not necessary to modify them, but can be done if preferred.

To generate autocompletion for YAML OSCAL documents must install 
YAML extension by Red Hat, as VS Code doesn't have the functionality 
prepackaged.





The shared volume can contain:
    - oscal files uploaded for validation
    - a validation results file 
    - generated oscal documents 
    - CWEs found to be effective 

Right now, generated documents are not going to 
flask/oscal_schemas/type/
Need to be careful as writing directly would overwrite existing files.
flask/oscal_schemas/type/ right now are for editing.


Next steps:
- validate NIST OSCAL docs
- ask cli converter command
- check trestle

Easy Dynamics: (No esta leyendo el formato de NIST)
Para usar Easy Dynamics
Hay que crear un folder con la estructura:
oscal-content/
├── catalogs
├── component-definitions
├── profiles
└── system-security-plans
Los documentos van dentro de esos folders.
Tienen que estar en json format.
Hay que hacerle pull a este image:
docker pull ghcr.io/easydynamics/oscal-editor-all-in-one

Desde el folder que contenga a tu oscal-content, start the editor container:
docker run -p 8080:8080 -v "$(pwd)"/oscal-content:/app/oscal-content ghcr.io/easydynamics/oscal-editor-all-in-one

(Si confirmamos que los cambios se guardadn en el documento (en un volume))
docker run --rm -p 8080:8080 -v "$(pwd)"/oscal-content:/app/oscal-content ghcr.io/easydynamics/oscal-editor-all-in-one
(le ponemos el rm al cmd)

And that's it.


Si tenemos un dockerfile, lo ponemos con docker-compose

Si solo tenemos el image, usamos docker run, como el CLI










Pusimos flask/dependencies y flask/artifacts en .gitignore
Pero la realidad es que todo lo que se baja y se produce,
ahora mismo, vive en el container,
es independiente del codigo.

Upload function
# Estamos usando el request object de dos formas distintas.
# Entender bien el request object ayudaria.
# Y shutil.
# Estamos atados a este objeto debido al interface que tenemos.


url_for()
Has an optional parameter for variable arguments.
(for routes that accept variable parameters)
These argumetns are passed as keyword arguments.
When you define a f with **kwargs as a parameter,
it allows you to pass an arbitrary number of keyword arguments to the f.
These keyword arguments are passed as a dict,
where the keys are the argument names,
and the values are the corresponding values.




Hay que check Tactic Selection



Vulnerability Effectiveness
It executes from "/" hitting the test button in the UI.
The route for that click is Vulnerability_effectiveness.
The command executes the vulnerability effectiveness analysis in
the dependencies.projectName program starting at the said function.

Artifacts are generated 
When these artifacts are present in the artifacts/ folder in the container,
the vulnerability effectiveness results table is created when the 
CreateVisualizations object executes.
The table requires data from some of the files there in order to be able to display it.
Since we can build the image every time,
These files could be added to the folder and then build the image.
Are these files available in a volume?

We want to see if we find the vuln in the inserted function.
Then not call it, and see if it is ignored in the final recommendations.

